using Autofac.Util;
using Newtonsoft.Json;
using StatePipes.Common;
using StatePipes.Common.Internal;
using StatePipes.Interfaces;
using System.Reflection;

namespace StatePipes.Comms.Internal
{
    internal class LocalProxyMessageTypeTransformer
    {
        private readonly Dictionary<string, Type> _subscribedEventTypeDictionary = [];
        private readonly Dictionary<string, Type> _publicCommandTypeDictionary = [];
        private static bool IsConcrete(Type type) => !type.IsAbstract && !type.IsInterface && !type.IsGenericTypeDefinition && !type.IsGenericType;
        public void PopulatePublicCommandTypeDictionary(Assembly _assembly)
        {
            var types = _assembly.GetLoadableTypes().Where(t => (t.IsPublic && IsConcrete(t) && 
                typeof(ICommand).IsAssignableFrom(t) && !string.IsNullOrEmpty(t.FullName)));
            if (types == null) return;
            types.ToList().ForEach(t => _publicCommandTypeDictionary.Add(t.FullName!, t));
            return;
        }
        public void AddEventType(string receivedEventTypeFullName, Type eventType)
        {
            if (eventType.FullName != receivedEventTypeFullName) _subscribedEventTypeDictionary.Add(receivedEventTypeFullName, eventType);
        }
        public dynamic? TransformEventToValueObject<TEvent>(TEvent eventMessage) where TEvent : class, IEvent
        {
            //This json cloning only effects locally deployed services using autogenerated proxies.
            var eventTypeFullName = typeof(TEvent).FullName;
            if (string.IsNullOrEmpty(eventTypeFullName)) return null;
            if (!_subscribedEventTypeDictionary.TryGetValue(eventTypeFullName, out Type? subscribedEventType)) return null;
            return JsonConvert.DeserializeObject(JsonUtility.GetJsonStringForObject(eventMessage, false), subscribedEventType, StatePipesJsonConverters.Converters);
        }
        public dynamic? TransformValueObjectToCommand<TValueObject>(string? sendCommandFullName, TValueObject commandMessage) where TValueObject : class
        {
            //This json cloning only effects locally deployed services using autogenerated proxies.
            if (string.IsNullOrEmpty(sendCommandFullName)) return null;
            if (!_publicCommandTypeDictionary.TryGetValue(sendCommandFullName, out Type? commandType)) return null;
            return JsonConvert.DeserializeObject(JsonUtility.GetJsonStringForObject(commandMessage, false), commandType, StatePipesJsonConverters.Converters);
        }
    }
}
